{"ast":null,"code":"import { Trigger } from './trigger.class';\nvar DEFAULT_ALIASES = {\n  hover: ['mouseenter', 'mouseleave'],\n  focus: ['focusin', 'focusout']\n};\nexport function parseTriggers(triggers, aliases) {\n  if (aliases === void 0) {\n    aliases = DEFAULT_ALIASES;\n  }\n\n  var trimmedTriggers = (triggers || '').trim();\n\n  if (trimmedTriggers.length === 0) {\n    return [];\n  }\n\n  var parsedTriggers = trimmedTriggers.split(/\\s+/).map(function (trigger) {\n    return trigger.split(':');\n  }).map(function (triggerPair) {\n    var alias = aliases[triggerPair[0]] || triggerPair;\n    return new Trigger(alias[0], alias[1]);\n  });\n  var manualTriggers = parsedTriggers.filter(function (triggerPair) {\n    return triggerPair.isManual();\n  });\n\n  if (manualTriggers.length > 1) {\n    throw 'Triggers parse error: only one manual trigger is allowed';\n  }\n\n  if (manualTriggers.length === 1 && parsedTriggers.length > 1) {\n    throw 'Triggers parse error: manual trigger can\\'t be mixed with other triggers';\n  }\n\n  return parsedTriggers;\n}\nexport function listenToTriggers(renderer, target, triggers, showFn, hideFn, toggleFn) {\n  var parsedTriggers = parseTriggers(triggers);\n  var listeners = [];\n\n  if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {\n    return Function.prototype;\n  }\n\n  parsedTriggers.forEach(function (trigger) {\n    if (trigger.open === trigger.close) {\n      listeners.push(renderer.listen(target, trigger.open, toggleFn));\n      return;\n    }\n\n    listeners.push(renderer.listen(target, trigger.open, showFn), renderer.listen(target, trigger.close, hideFn));\n  });\n  return function () {\n    listeners.forEach(function (unsubscribeFn) {\n      return unsubscribeFn();\n    });\n  };\n}","map":{"version":3,"names":["Trigger","DEFAULT_ALIASES","hover","focus","parseTriggers","triggers","aliases","trimmedTriggers","trim","length","parsedTriggers","split","map","trigger","triggerPair","alias","manualTriggers","filter","isManual","listenToTriggers","renderer","target","showFn","hideFn","toggleFn","listeners","Function","prototype","forEach","open","close","push","listen","unsubscribeFn"],"sources":["C:/Users/Adam/Desktop/angular formation harington/FormationHarington/node_modules/ng-bootstrap/utils/triggers.js"],"sourcesContent":["import { Trigger } from './trigger.class';\nvar DEFAULT_ALIASES = {\n    hover: ['mouseenter', 'mouseleave'],\n    focus: ['focusin', 'focusout']\n};\nexport function parseTriggers(triggers, aliases) {\n    if (aliases === void 0) { aliases = DEFAULT_ALIASES; }\n    var trimmedTriggers = (triggers || '').trim();\n    if (trimmedTriggers.length === 0) {\n        return [];\n    }\n    var parsedTriggers = trimmedTriggers.split(/\\s+/)\n        .map(function (trigger) { return trigger.split(':'); })\n        .map(function (triggerPair) {\n        var alias = aliases[triggerPair[0]] || triggerPair;\n        return new Trigger(alias[0], alias[1]);\n    });\n    var manualTriggers = parsedTriggers\n        .filter(function (triggerPair) { return triggerPair.isManual(); });\n    if (manualTriggers.length > 1) {\n        throw 'Triggers parse error: only one manual trigger is allowed';\n    }\n    if (manualTriggers.length === 1 && parsedTriggers.length > 1) {\n        throw 'Triggers parse error: manual trigger can\\'t be mixed with other triggers';\n    }\n    return parsedTriggers;\n}\nexport function listenToTriggers(renderer, target, triggers, showFn, hideFn, toggleFn) {\n    var parsedTriggers = parseTriggers(triggers);\n    var listeners = [];\n    if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {\n        return Function.prototype;\n    }\n    parsedTriggers.forEach(function (trigger) {\n        if (trigger.open === trigger.close) {\n            listeners.push(renderer.listen(target, trigger.open, toggleFn));\n            return;\n        }\n        listeners.push(renderer.listen(target, trigger.open, showFn), renderer.listen(target, trigger.close, hideFn));\n    });\n    return function () { listeners.forEach(function (unsubscribeFn) { return unsubscribeFn(); }); };\n}\n"],"mappings":"AAAA,SAASA,OAAT,QAAwB,iBAAxB;AACA,IAAIC,eAAe,GAAG;EAClBC,KAAK,EAAE,CAAC,YAAD,EAAe,YAAf,CADW;EAElBC,KAAK,EAAE,CAAC,SAAD,EAAY,UAAZ;AAFW,CAAtB;AAIA,OAAO,SAASC,aAAT,CAAuBC,QAAvB,EAAiCC,OAAjC,EAA0C;EAC7C,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAGL,eAAV;EAA4B;;EACtD,IAAIM,eAAe,GAAG,CAACF,QAAQ,IAAI,EAAb,EAAiBG,IAAjB,EAAtB;;EACA,IAAID,eAAe,CAACE,MAAhB,KAA2B,CAA/B,EAAkC;IAC9B,OAAO,EAAP;EACH;;EACD,IAAIC,cAAc,GAAGH,eAAe,CAACI,KAAhB,CAAsB,KAAtB,EAChBC,GADgB,CACZ,UAAUC,OAAV,EAAmB;IAAE,OAAOA,OAAO,CAACF,KAAR,CAAc,GAAd,CAAP;EAA4B,CADrC,EAEhBC,GAFgB,CAEZ,UAAUE,WAAV,EAAuB;IAC5B,IAAIC,KAAK,GAAGT,OAAO,CAACQ,WAAW,CAAC,CAAD,CAAZ,CAAP,IAA2BA,WAAvC;IACA,OAAO,IAAId,OAAJ,CAAYe,KAAK,CAAC,CAAD,CAAjB,EAAsBA,KAAK,CAAC,CAAD,CAA3B,CAAP;EACH,CALoB,CAArB;EAMA,IAAIC,cAAc,GAAGN,cAAc,CAC9BO,MADgB,CACT,UAAUH,WAAV,EAAuB;IAAE,OAAOA,WAAW,CAACI,QAAZ,EAAP;EAAgC,CADhD,CAArB;;EAEA,IAAIF,cAAc,CAACP,MAAf,GAAwB,CAA5B,EAA+B;IAC3B,MAAM,0DAAN;EACH;;EACD,IAAIO,cAAc,CAACP,MAAf,KAA0B,CAA1B,IAA+BC,cAAc,CAACD,MAAf,GAAwB,CAA3D,EAA8D;IAC1D,MAAM,0EAAN;EACH;;EACD,OAAOC,cAAP;AACH;AACD,OAAO,SAASS,gBAAT,CAA0BC,QAA1B,EAAoCC,MAApC,EAA4ChB,QAA5C,EAAsDiB,MAAtD,EAA8DC,MAA9D,EAAsEC,QAAtE,EAAgF;EACnF,IAAId,cAAc,GAAGN,aAAa,CAACC,QAAD,CAAlC;EACA,IAAIoB,SAAS,GAAG,EAAhB;;EACA,IAAIf,cAAc,CAACD,MAAf,KAA0B,CAA1B,IAA+BC,cAAc,CAAC,CAAD,CAAd,CAAkBQ,QAAlB,EAAnC,EAAiE;IAC7D,OAAOQ,QAAQ,CAACC,SAAhB;EACH;;EACDjB,cAAc,CAACkB,OAAf,CAAuB,UAAUf,OAAV,EAAmB;IACtC,IAAIA,OAAO,CAACgB,IAAR,KAAiBhB,OAAO,CAACiB,KAA7B,EAAoC;MAChCL,SAAS,CAACM,IAAV,CAAeX,QAAQ,CAACY,MAAT,CAAgBX,MAAhB,EAAwBR,OAAO,CAACgB,IAAhC,EAAsCL,QAAtC,CAAf;MACA;IACH;;IACDC,SAAS,CAACM,IAAV,CAAeX,QAAQ,CAACY,MAAT,CAAgBX,MAAhB,EAAwBR,OAAO,CAACgB,IAAhC,EAAsCP,MAAtC,CAAf,EAA8DF,QAAQ,CAACY,MAAT,CAAgBX,MAAhB,EAAwBR,OAAO,CAACiB,KAAhC,EAAuCP,MAAvC,CAA9D;EACH,CAND;EAOA,OAAO,YAAY;IAAEE,SAAS,CAACG,OAAV,CAAkB,UAAUK,aAAV,EAAyB;MAAE,OAAOA,aAAa,EAApB;IAAyB,CAAtE;EAA0E,CAA/F;AACH"},"metadata":{},"sourceType":"module"}